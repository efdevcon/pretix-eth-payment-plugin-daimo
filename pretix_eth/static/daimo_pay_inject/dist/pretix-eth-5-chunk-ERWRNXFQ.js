import{A as j,B as Jt,C as $,D as $t,E as V,F as K,G as Zt,H as pt,I as F,J as Ae,K as lt,L as Ie,M as tt,N as Ft,f as ye,g as Nt,h as Ee,i as mt,j as Be,l as dt,m as Rt,n as X,p as Tt,q as ve,r as Ct,s as Se,t as Ut,u as Xt,v as wt,w as gt,x as St,y as kt,z as Qt}from"./pretix-eth-5-chunk-UYVEV2Z2.js";function nn(e,n,t,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(n,t,r);let i=BigInt(32),s=BigInt(4294967295),c=Number(t>>i&s),a=Number(t&s),o=r?4:0,f=r?0:4;e.setUint32(n+o,c,r),e.setUint32(n+f,a,r)}function _e(e,n,t){return e&n^~e&t}function He(e,n,t){return e&n^e&t^n&t}var Vt=class extends Ct{constructor(n,t,r,i){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=n,this.outputLen=t,this.padOffset=r,this.isLE=i,this.buffer=new Uint8Array(n),this.view=Rt(this.buffer)}update(n){mt(this),n=Tt(n),Nt(n);let{view:t,buffer:r,blockLen:i}=this,s=n.length;for(let c=0;c<s;){let a=Math.min(i-this.pos,s-c);if(a===i){let o=Rt(n);for(;i<=s-c;c+=i)this.process(o,c);continue}r.set(n.subarray(c,c+a),this.pos),this.pos+=a,c+=a,this.pos===i&&(this.process(t,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){mt(this),Be(n,this),this.finished=!0;let{buffer:t,view:r,blockLen:i,isLE:s}=this,{pos:c}=this;t[c++]=128,dt(this.buffer.subarray(c)),this.padOffset>i-c&&(this.process(r,0),c=0);for(let h=c;h<i;h++)t[h]=0;nn(r,i-8,BigInt(this.length*8),s),this.process(r,0);let a=Rt(n),o=this.outputLen;if(o%4)throw new Error("_sha2: outputLen should be aligned to 32bit");let f=o/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<f;h++)a.setUint32(4*h,l[h],s)}digest(){let{buffer:n,outputLen:t}=this;this.digestInto(n);let r=n.slice(0,t);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());let{blockLen:t,buffer:r,length:i,finished:s,destroyed:c,pos:a}=this;return n.destroyed=c,n.finished=s,n.length=i,n.pos=a,i%t&&n.buffer.set(r),n}clone(){return this._cloneInto()}},et=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var rn=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),ot=new Uint32Array(64),te=class extends Vt{constructor(n=32){super(64,n,8,!1),this.A=et[0]|0,this.B=et[1]|0,this.C=et[2]|0,this.D=et[3]|0,this.E=et[4]|0,this.F=et[5]|0,this.G=et[6]|0,this.H=et[7]|0}get(){let{A:n,B:t,C:r,D:i,E:s,F:c,G:a,H:o}=this;return[n,t,r,i,s,c,a,o]}set(n,t,r,i,s,c,a,o){this.A=n|0,this.B=t|0,this.C=r|0,this.D=i|0,this.E=s|0,this.F=c|0,this.G=a|0,this.H=o|0}process(n,t){for(let h=0;h<16;h++,t+=4)ot[h]=n.getUint32(t,!1);for(let h=16;h<64;h++){let E=ot[h-15],y=ot[h-2],I=X(E,7)^X(E,18)^E>>>3,b=X(y,17)^X(y,19)^y>>>10;ot[h]=b+ot[h-7]+I+ot[h-16]|0}let{A:r,B:i,C:s,D:c,E:a,F:o,G:f,H:l}=this;for(let h=0;h<64;h++){let E=X(a,6)^X(a,11)^X(a,25),y=l+E+_e(a,o,f)+rn[h]+ot[h]|0,b=(X(r,2)^X(r,13)^X(r,22))+He(r,i,s)|0;l=f,f=o,o=a,a=c+y|0,c=s,s=i,i=r,r=y+b|0}r=r+this.A|0,i=i+this.B|0,s=s+this.C|0,c=c+this.D|0,a=a+this.E|0,o=o+this.F|0,f=f+this.G|0,l=l+this.H|0,this.set(r,i,s,c,a,o,f,l)}roundClean(){dt(ot)}destroy(){this.set(0,0,0,0,0,0,0,0),dt(this.buffer)}};var At=Se(()=>new te);var Mt=class extends Ct{constructor(n,t){super(),this.finished=!1,this.destroyed=!1,Ee(n);let r=Tt(t);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;let i=this.blockLen,s=new Uint8Array(i);s.set(r.length>i?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),dt(s)}update(n){return mt(this),this.iHash.update(n),this}digestInto(n){mt(this),Nt(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){let n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));let{oHash:t,iHash:r,finished:i,destroyed:s,blockLen:c,outputLen:a}=this;return n=n,n.finished=i,n.destroyed=s,n.blockLen=c,n.outputLen=a,n.oHash=t._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}},ee=(e,n,t)=>new Mt(e,n).update(t).digest();ee.create=(e,n)=>new Mt(e,n);var P=BigInt(0),D=BigInt(1),ut=BigInt(2),on=BigInt(3),qe=BigInt(4),Le=BigInt(5),Ne=BigInt(8);function Z(e,n){let t=e%n;return t>=P?t:n+t}function Y(e,n,t){let r=e;for(;n-- >P;)r*=r,r%=t;return r}function Dt(e,n){if(e===P)throw new Error("invert: expected non-zero number");if(n<=P)throw new Error("invert: expected positive modulus, got "+n);let t=Z(e,n),r=n,i=P,s=D,c=D,a=P;for(;t!==P;){let f=r/t,l=r%t,h=i-c*f,E=s-a*f;r=t,t=l,i=c,s=a,c=h,a=E}if(r!==D)throw new Error("invert: does not exist");return Z(i,n)}function Re(e,n){let t=(e.ORDER+D)/qe,r=e.pow(n,t);if(!e.eql(e.sqr(r),n))throw new Error("Cannot find square root");return r}function sn(e,n){let t=(e.ORDER-Le)/Ne,r=e.mul(n,ut),i=e.pow(r,t),s=e.mul(n,i),c=e.mul(e.mul(s,ut),i),a=e.mul(s,e.sub(c,e.ONE));if(!e.eql(e.sqr(a),n))throw new Error("Cannot find square root");return a}function cn(e){if(e<BigInt(3))throw new Error("sqrt is not defined for small field");let n=e-D,t=0;for(;n%ut===P;)n/=ut,t++;let r=ut,i=It(e);for(;Oe(i,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(t===1)return Re;let s=i.pow(r,n),c=(n+D)/ut;return function(o,f){if(o.is0(f))return f;if(Oe(o,f)!==1)throw new Error("Cannot find square root");let l=t,h=o.mul(o.ONE,s),E=o.pow(f,n),y=o.pow(f,c);for(;!o.eql(E,o.ONE);){if(o.is0(E))return o.ZERO;let I=1,b=o.sqr(E);for(;!o.eql(b,o.ONE);)if(I++,b=o.sqr(b),I===l)throw new Error("Cannot find square root");let C=D<<BigInt(l-I-1),_=o.pow(h,C);l=I,h=o.sqr(_),E=o.mul(E,h),y=o.mul(y,_)}return y}}function an(e){return e%qe===on?Re:e%Ne===Le?sn:cn(e)}var fn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function zt(e){let n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},t=fn.reduce((r,i)=>(r[i]="function",r),n);return tt(e,t)}function dn(e,n,t){if(t<P)throw new Error("invalid exponent, negatives unsupported");if(t===P)return e.ONE;if(t===D)return n;let r=e.ONE,i=n;for(;t>P;)t&D&&(r=e.mul(r,i)),i=e.sqr(i),t>>=D;return r}function yt(e,n,t=!1){let r=new Array(n.length).fill(t?e.ZERO:void 0),i=n.reduce((c,a,o)=>e.is0(a)?c:(r[o]=c,e.mul(c,a)),e.ONE),s=e.inv(i);return n.reduceRight((c,a,o)=>e.is0(a)?c:(r[o]=e.mul(c,r[o]),e.mul(c,a)),s),r}function Oe(e,n){let t=(e.ORDER-D)/ut,r=e.pow(n,t),i=e.eql(r,e.ONE),s=e.eql(r,e.ZERO),c=e.eql(r,e.neg(e.ONE));if(!i&&!s&&!c)throw new Error("invalid Legendre symbol result");return i?1:s?0:-1}function ne(e,n){n!==void 0&&ye(n);let t=n!==void 0?n:e.toString(2).length,r=Math.ceil(t/8);return{nBitLength:t,nByteLength:r}}function It(e,n,t=!1,r={}){if(e<=P)throw new Error("invalid field: expected ORDER > 0, got "+e);let{nBitLength:i,nByteLength:s}=ne(e,n);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let c,a=Object.freeze({ORDER:e,isLE:t,BITS:i,BYTES:s,MASK:lt(i),ZERO:P,ONE:D,create:o=>Z(o,e),isValid:o=>{if(typeof o!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof o);return P<=o&&o<e},is0:o=>o===P,isOdd:o=>(o&D)===D,neg:o=>Z(-o,e),eql:(o,f)=>o===f,sqr:o=>Z(o*o,e),add:(o,f)=>Z(o+f,e),sub:(o,f)=>Z(o-f,e),mul:(o,f)=>Z(o*f,e),pow:(o,f)=>dn(a,o,f),div:(o,f)=>Z(o*Dt(f,e),e),sqrN:o=>o*o,addN:(o,f)=>o+f,subN:(o,f)=>o-f,mulN:(o,f)=>o*f,inv:o=>Dt(o,e),sqrt:r.sqrt||(o=>(c||(c=an(e)),c(a,o))),toBytes:o=>t?$t(o,s):$(o,s),fromBytes:o=>{if(o.length!==s)throw new Error("Field.fromBytes: expected "+s+" bytes, got "+o.length);return t?Jt(o):j(o)},invertBatch:o=>yt(a,o),cmov:(o,f,l)=>l?f:o});return Object.freeze(a)}function Te(e){if(typeof e!="bigint")throw new Error("field order must be bigint");let n=e.toString(2).length;return Math.ceil(n/8)}function re(e){let n=Te(e);return n+Math.ceil(n/2)}function Ce(e,n,t=!1){let r=e.length,i=Te(n),s=re(n);if(r<16||r<s||r>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+r);let c=t?Jt(e):j(e),a=Z(c,n-D)+D;return t?$t(a,i):$(a,i)}var Ue=BigInt(0),ae=BigInt(1);function oe(e,n){let t=n.negate();return e?t:n}function Ze(e,n){if(!Number.isSafeInteger(e)||e<=0||e>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+e)}function se(e,n){Ze(e,n);let t=Math.ceil(n/e)+1,r=2**(e-1),i=2**e,s=lt(e),c=BigInt(e);return{windows:t,windowSize:r,mask:s,maxNumber:i,shiftBy:c}}function ke(e,n,t){let{windowSize:r,mask:i,maxNumber:s,shiftBy:c}=t,a=Number(e&i),o=e>>c;a>r&&(a-=s,o+=ae);let f=n*r,l=f+Math.abs(a)-1,h=a===0,E=a<0,y=n%2!==0;return{nextN:o,offset:l,isZero:h,isNeg:E,isNegF:y,offsetF:f}}function ln(e,n){if(!Array.isArray(e))throw new Error("array expected");e.forEach((t,r)=>{if(!(t instanceof n))throw new Error("invalid point at index "+r)})}function un(e,n){if(!Array.isArray(e))throw new Error("array of scalars expected");e.forEach((t,r)=>{if(!n.isValid(t))throw new Error("invalid scalar at index "+r)})}var ie=new WeakMap,Ve=new WeakMap;function ce(e){return Ve.get(e)||1}function Me(e,n){return{constTimeNegate:oe,hasPrecomputes(t){return ce(t)!==1},unsafeLadder(t,r,i=e.ZERO){let s=t;for(;r>Ue;)r&ae&&(i=i.add(s)),s=s.double(),r>>=ae;return i},precomputeWindow(t,r){let{windows:i,windowSize:s}=se(r,n),c=[],a=t,o=a;for(let f=0;f<i;f++){o=a,c.push(o);for(let l=1;l<s;l++)o=o.add(a),c.push(o);a=o.double()}return c},wNAF(t,r,i){let s=e.ZERO,c=e.BASE,a=se(t,n);for(let o=0;o<a.windows;o++){let{nextN:f,offset:l,isZero:h,isNeg:E,isNegF:y,offsetF:I}=ke(i,o,a);i=f,h?c=c.add(oe(y,r[I])):s=s.add(oe(E,r[l]))}return{p:s,f:c}},wNAFUnsafe(t,r,i,s=e.ZERO){let c=se(t,n);for(let a=0;a<c.windows&&i!==Ue;a++){let{nextN:o,offset:f,isZero:l,isNeg:h}=ke(i,a,c);if(i=o,!l){let E=r[f];s=s.add(h?E.negate():E)}}return s},getPrecomputes(t,r,i){let s=ie.get(r);return s||(s=this.precomputeWindow(r,t),t!==1&&ie.set(r,i(s))),s},wNAFCached(t,r,i){let s=ce(t);return this.wNAF(s,this.getPrecomputes(s,t,i),r)},wNAFCachedUnsafe(t,r,i,s){let c=ce(t);return c===1?this.unsafeLadder(t,r,s):this.wNAFUnsafe(c,this.getPrecomputes(c,t,i),r,s)},setWindowSize(t,r){Ze(r,n),Ve.set(t,r),ie.delete(t)}}}function De(e,n,t,r){ln(t,e),un(r,n);let i=t.length,s=r.length;if(i!==s)throw new Error("arrays of points and scalars must have equal length");let c=e.ZERO,a=Ae(BigInt(i)),o=1;a>12?o=a-3:a>4?o=a-2:a>0&&(o=2);let f=lt(o),l=new Array(Number(f)+1).fill(c),h=Math.floor((n.BITS-1)/o)*o,E=c;for(let y=h;y>=0;y-=o){l.fill(c);for(let b=0;b<s;b++){let C=r[b],_=Number(C>>BigInt(y)&f);l[_]=l[_].add(t[b])}let I=c;for(let b=l.length-1,C=c;b>0;b--)C=C.add(l[b]),I=I.add(C);if(E=E.add(I),y!==0)for(let b=0;b<o;b++)E=E.double()}return E}function fe(e){return zt(e.Fp),tt(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ne(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}function ze(e){e.lowS!==void 0&&gt("lowS",e.lowS),e.prehash!==void 0&&gt("prehash",e.prehash)}function hn(e){let n=fe(e);tt(n,{a:"field",b:"field"},{allowInfinityPoint:"boolean",allowedPrivateKeyLengths:"array",clearCofactor:"function",fromBytes:"function",isTorsionFree:"function",toBytes:"function",wrapPrivateKey:"boolean"});let{endo:t,Fp:r,a:i}=n;if(t){if(!r.eql(i,r.ZERO))throw new Error("invalid endo: CURVE.a must be 0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error('invalid endo: expected "beta": bigint and "splitScalar": function')}return Object.freeze({...n})}var le=class extends Error{constructor(n=""){super(n)}},nt={Err:le,_tlv:{encode:(e,n)=>{let{Err:t}=nt;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length&1)throw new t("tlv.encode: unpadded data");let r=n.length/2,i=St(r);if(i.length/2&128)throw new t("tlv.encode: long form length too big");let s=r>127?St(i.length/2|128):"";return St(e)+s+i+n},decode(e,n){let{Err:t}=nt,r=0;if(e<0||e>256)throw new t("tlv.encode: wrong tag");if(n.length<2||n[r++]!==e)throw new t("tlv.decode: wrong tlv");let i=n[r++],s=!!(i&128),c=0;if(!s)c=i;else{let o=i&127;if(!o)throw new t("tlv.decode(long): indefinite length not supported");if(o>4)throw new t("tlv.decode(long): byte length is too big");let f=n.subarray(r,r+o);if(f.length!==o)throw new t("tlv.decode: length bytes not complete");if(f[0]===0)throw new t("tlv.decode(long): zero leftmost byte");for(let l of f)c=c<<8|l;if(r+=o,c<128)throw new t("tlv.decode(long): not minimal encoding")}let a=n.subarray(r,r+c);if(a.length!==c)throw new t("tlv.decode: wrong value length");return{v:a,l:n.subarray(r+c)}}},_int:{encode(e){let{Err:n}=nt;if(e<Q)throw new n("integer: negative integers are not allowed");let t=St(e);if(Number.parseInt(t[0],16)&8&&(t="00"+t),t.length&1)throw new n("unexpected DER parsing assertion: unpadded hex");return t},decode(e){let{Err:n}=nt;if(e[0]&128)throw new n("invalid signature integer: negative");if(e[0]===0&&!(e[1]&128))throw new n("invalid signature integer: unnecessary leading zero");return j(e)}},toSig(e){let{Err:n,_int:t,_tlv:r}=nt,i=V("signature",e),{v:s,l:c}=r.decode(48,i);if(c.length)throw new n("invalid signature: left bytes after parsing");let{v:a,l:o}=r.decode(2,s),{v:f,l}=r.decode(2,o);if(l.length)throw new n("invalid signature: left bytes after parsing");return{r:t.decode(a),s:t.decode(f)}},hexFromSig(e){let{_tlv:n,_int:t}=nt,r=n.encode(2,t.encode(e.r)),i=n.encode(2,t.encode(e.s)),s=r+i;return n.encode(48,s)}};function de(e,n){return kt($(e,n))}var Q=BigInt(0),U=BigInt(1),st=BigInt(2),_t=BigInt(3),ue=BigInt(4);function xn(e){let n=hn(e),{Fp:t}=n,r=It(n.n,n.nBitLength),i=n.toBytes||((w,d,m)=>{let g=d.toAffine();return K(Uint8Array.from([4]),t.toBytes(g.x),t.toBytes(g.y))}),s=n.fromBytes||(w=>{let d=w.subarray(1),m=t.fromBytes(d.subarray(0,t.BYTES)),g=t.fromBytes(d.subarray(t.BYTES,2*t.BYTES));return{x:m,y:g}});function c(w){let{a:d,b:m}=n,g=t.sqr(w),B=t.mul(g,w);return t.add(t.add(B,t.mul(w,d)),m)}function a(w,d){let m=t.sqr(d),g=c(w);return t.eql(m,g)}if(!a(n.Gx,n.Gy))throw new Error("bad curve params: generator point");let o=t.mul(t.pow(n.a,_t),ue),f=t.mul(t.sqr(n.b),BigInt(27));if(t.is0(t.add(o,f)))throw new Error("bad curve params: a or b");function l(w){return pt(w,U,n.n)}function h(w){let{allowedPrivateKeyLengths:d,nByteLength:m,wrapPrivateKey:g,n:B}=n;if(d&&typeof w!="bigint"){if(Xt(w)&&(w=kt(w)),typeof w!="string"||!d.includes(w.length))throw new Error("invalid private key");w=w.padStart(m*2,"0")}let H;try{H=typeof w=="bigint"?w:j(V("private key",w,m))}catch{throw new Error("invalid private key, expected hex or "+m+" bytes, got "+typeof w)}return g&&(H=Z(H,B)),F("private key",H,U,B),H}function E(w){if(!(w instanceof b))throw new Error("ProjectivePoint expected")}let y=Ft((w,d)=>{let{px:m,py:g,pz:B}=w;if(t.eql(B,t.ONE))return{x:m,y:g};let H=w.is0();d==null&&(d=H?t.ONE:t.inv(B));let R=t.mul(m,d),T=t.mul(g,d),v=t.mul(B,d);if(H)return{x:t.ZERO,y:t.ZERO};if(!t.eql(v,t.ONE))throw new Error("invZ was invalid");return{x:R,y:T}}),I=Ft(w=>{if(w.is0()){if(n.allowInfinityPoint&&!t.is0(w.py))return;throw new Error("bad point: ZERO")}let{x:d,y:m}=w.toAffine();if(!t.isValid(d)||!t.isValid(m))throw new Error("bad point: x or y not FE");if(!a(d,m))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class b{constructor(d,m,g){if(d==null||!t.isValid(d))throw new Error("x required");if(m==null||!t.isValid(m)||t.is0(m))throw new Error("y required");if(g==null||!t.isValid(g))throw new Error("z required");this.px=d,this.py=m,this.pz=g,Object.freeze(this)}static fromAffine(d){let{x:m,y:g}=d||{};if(!d||!t.isValid(m)||!t.isValid(g))throw new Error("invalid affine point");if(d instanceof b)throw new Error("projective point not allowed");let B=H=>t.eql(H,t.ZERO);return B(m)&&B(g)?b.ZERO:new b(m,g,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){let m=yt(t,d.map(g=>g.pz));return d.map((g,B)=>g.toAffine(m[B])).map(b.fromAffine)}static fromHex(d){let m=b.fromAffine(s(V("pointHex",d)));return m.assertValidity(),m}static fromPrivateKey(d){return b.BASE.multiply(h(d))}static msm(d,m){return De(b,r,d,m)}_setWindowSize(d){N.setWindowSize(this,d)}assertValidity(){I(this)}hasEvenY(){let{y:d}=this.toAffine();if(t.isOdd)return!t.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){E(d);let{px:m,py:g,pz:B}=this,{px:H,py:R,pz:T}=d,v=t.eql(t.mul(m,T),t.mul(H,B)),L=t.eql(t.mul(g,T),t.mul(R,B));return v&&L}negate(){return new b(this.px,t.neg(this.py),this.pz)}double(){let{a:d,b:m}=n,g=t.mul(m,_t),{px:B,py:H,pz:R}=this,T=t.ZERO,v=t.ZERO,L=t.ZERO,S=t.mul(B,B),M=t.mul(H,H),x=t.mul(R,R),u=t.mul(B,H);return u=t.add(u,u),L=t.mul(B,R),L=t.add(L,L),T=t.mul(d,L),v=t.mul(g,x),v=t.add(T,v),T=t.sub(M,v),v=t.add(M,v),v=t.mul(T,v),T=t.mul(u,T),L=t.mul(g,L),x=t.mul(d,x),u=t.sub(S,x),u=t.mul(d,u),u=t.add(u,L),L=t.add(S,S),S=t.add(L,S),S=t.add(S,x),S=t.mul(S,u),v=t.add(v,S),x=t.mul(H,R),x=t.add(x,x),S=t.mul(x,u),T=t.sub(T,S),L=t.mul(x,M),L=t.add(L,L),L=t.add(L,L),new b(T,v,L)}add(d){E(d);let{px:m,py:g,pz:B}=this,{px:H,py:R,pz:T}=d,v=t.ZERO,L=t.ZERO,S=t.ZERO,M=n.a,x=t.mul(n.b,_t),u=t.mul(m,H),p=t.mul(g,R),q=t.mul(B,T),A=t.add(m,g),O=t.add(H,R);A=t.mul(A,O),O=t.add(u,p),A=t.sub(A,O),O=t.add(m,B);let k=t.add(H,T);return O=t.mul(O,k),k=t.add(u,q),O=t.sub(O,k),k=t.add(g,B),v=t.add(R,T),k=t.mul(k,v),v=t.add(p,q),k=t.sub(k,v),S=t.mul(M,O),v=t.mul(x,q),S=t.add(v,S),v=t.sub(p,S),S=t.add(p,S),L=t.mul(v,S),p=t.add(u,u),p=t.add(p,u),q=t.mul(M,q),O=t.mul(x,O),p=t.add(p,q),q=t.sub(u,q),q=t.mul(M,q),O=t.add(O,q),u=t.mul(p,O),L=t.add(L,u),u=t.mul(k,O),v=t.mul(A,v),v=t.sub(v,u),u=t.mul(A,p),S=t.mul(k,S),S=t.add(S,u),new b(v,L,S)}subtract(d){return this.add(d.negate())}is0(){return this.equals(b.ZERO)}wNAF(d){return N.wNAFCached(this,d,b.normalizeZ)}multiplyUnsafe(d){let{endo:m,n:g}=n;F("scalar",d,Q,g);let B=b.ZERO;if(d===Q)return B;if(this.is0()||d===U)return this;if(!m||N.hasPrecomputes(this))return N.wNAFCachedUnsafe(this,d,b.normalizeZ);let{k1neg:H,k1:R,k2neg:T,k2:v}=m.splitScalar(d),L=B,S=B,M=this;for(;R>Q||v>Q;)R&U&&(L=L.add(M)),v&U&&(S=S.add(M)),M=M.double(),R>>=U,v>>=U;return H&&(L=L.negate()),T&&(S=S.negate()),S=new b(t.mul(S.px,m.beta),S.py,S.pz),L.add(S)}multiply(d){let{endo:m,n:g}=n;F("scalar",d,U,g);let B,H;if(m){let{k1neg:R,k1:T,k2neg:v,k2:L}=m.splitScalar(d),{p:S,f:M}=this.wNAF(T),{p:x,f:u}=this.wNAF(L);S=N.constTimeNegate(R,S),x=N.constTimeNegate(v,x),x=new b(t.mul(x.px,m.beta),x.py,x.pz),B=S.add(x),H=M.add(u)}else{let{p:R,f:T}=this.wNAF(d);B=R,H=T}return b.normalizeZ([B,H])[0]}multiplyAndAddUnsafe(d,m,g){let B=b.BASE,H=(T,v)=>v===Q||v===U||!T.equals(B)?T.multiplyUnsafe(v):T.multiply(v),R=H(this,m).add(H(d,g));return R.is0()?void 0:R}toAffine(d){return y(this,d)}isTorsionFree(){let{h:d,isTorsionFree:m}=n;if(d===U)return!0;if(m)return m(b,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){let{h:d,clearCofactor:m}=n;return d===U?this:m?m(b,this):this.multiplyUnsafe(n.h)}toRawBytes(d=!0){return gt("isCompressed",d),this.assertValidity(),i(b,this,d)}toHex(d=!0){return gt("isCompressed",d),kt(this.toRawBytes(d))}}b.BASE=new b(n.Gx,n.Gy,t.ONE),b.ZERO=new b(t.ZERO,t.ONE,t.ZERO);let{endo:C,nBitLength:_}=n,N=Me(b,C?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:b,normPrivateKeyToScalar:h,weierstrassEquation:c,isWithinCurveOrder:l}}function bn(e){let n=fe(e);return tt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Pe(e){let n=bn(e),{Fp:t,n:r,nByteLength:i,nBitLength:s}=n,c=t.BYTES+1,a=2*t.BYTES+1;function o(x){return Z(x,r)}function f(x){return Dt(x,r)}let{ProjectivePoint:l,normPrivateKeyToScalar:h,weierstrassEquation:E,isWithinCurveOrder:y}=xn({...n,toBytes(x,u,p){let q=u.toAffine(),A=t.toBytes(q.x),O=K;return gt("isCompressed",p),p?O(Uint8Array.from([u.hasEvenY()?2:3]),A):O(Uint8Array.from([4]),A,t.toBytes(q.y))},fromBytes(x){let u=x.length,p=x[0],q=x.subarray(1);if(u===c&&(p===2||p===3)){let A=j(q);if(!pt(A,U,t.ORDER))throw new Error("Point is not on curve");let O=E(A),k;try{k=t.sqrt(O)}catch(W){let G=W instanceof Error?": "+W.message:"";throw new Error("Point is not on curve"+G)}let z=(k&U)===U;return(p&1)===1!==z&&(k=t.neg(k)),{x:A,y:k}}else if(u===a&&p===4){let A=t.fromBytes(q.subarray(0,t.BYTES)),O=t.fromBytes(q.subarray(t.BYTES,2*t.BYTES));return{x:A,y:O}}else{let A=c,O=a;throw new Error("invalid Point, expected length of "+A+", or uncompressed "+O+", got "+u)}}});function I(x){let u=r>>U;return x>u}function b(x){return I(x)?o(-x):x}let C=(x,u,p)=>j(x.slice(u,p));class _{constructor(u,p,q){F("r",u,U,r),F("s",p,U,r),this.r=u,this.s=p,q!=null&&(this.recovery=q),Object.freeze(this)}static fromCompact(u){let p=i;return u=V("compactSignature",u,p*2),new _(C(u,0,p),C(u,p,2*p))}static fromDER(u){let{r:p,s:q}=nt.toSig(V("DER",u));return new _(p,q)}assertValidity(){}addRecoveryBit(u){return new _(this.r,this.s,u)}recoverPublicKey(u){let{r:p,s:q,recovery:A}=this,O=B(V("msgHash",u));if(A==null||![0,1,2,3].includes(A))throw new Error("recovery id invalid");let k=A===2||A===3?p+n.n:p;if(k>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");let z=A&1?"03":"02",J=l.fromHex(z+de(k,t.BYTES)),W=f(k),G=o(-O*W),ht=o(q*W),rt=l.BASE.multiplyAndAddUnsafe(J,G,ht);if(!rt)throw new Error("point at infinify");return rt.assertValidity(),rt}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,o(-this.s),this.recovery):this}toDERRawBytes(){return Qt(this.toDERHex())}toDERHex(){return nt.hexFromSig(this)}toCompactRawBytes(){return Qt(this.toCompactHex())}toCompactHex(){let u=i;return de(this.r,u)+de(this.s,u)}}let N={isValidPrivateKey(x){try{return h(x),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{let x=re(n.n);return Ce(n.randomBytes(x),n.n)},precompute(x=8,u=l.BASE){return u._setWindowSize(x),u.multiply(BigInt(3)),u}};function w(x,u=!0){return l.fromPrivateKey(x).toRawBytes(u)}function d(x){if(typeof x=="bigint")return!1;if(x instanceof l)return!0;let p=V("key",x).length,q=t.BYTES,A=q+1,O=2*q+1;if(!(n.allowedPrivateKeyLengths||i===A))return p===A||p===O}function m(x,u,p=!0){if(d(x)===!0)throw new Error("first arg must be private key");if(d(u)===!1)throw new Error("second arg must be public key");return l.fromHex(u).multiply(h(x)).toRawBytes(p)}let g=n.bits2int||function(x){if(x.length>8192)throw new Error("input is too large");let u=j(x),p=x.length*8-s;return p>0?u>>BigInt(p):u},B=n.bits2int_modN||function(x){return o(g(x))},H=lt(s);function R(x){return F("num < 2^"+s,x,Q,H),$(x,i)}function T(x,u,p=v){if(["recovered","canonical"].some(at=>at in p))throw new Error("sign() legacy options not supported");let{hash:q,randomBytes:A}=n,{lowS:O,prehash:k,extraEntropy:z}=p;O==null&&(O=!0),x=V("msgHash",x),ze(p),k&&(x=V("prehashed msgHash",q(x)));let J=B(x),W=h(u),G=[R(W),R(J)];if(z!=null&&z!==!1){let at=z===!0?A(t.BYTES):z;G.push(V("extraEntropy",at))}let ht=K(...G),rt=J;function Yt(at){let xt=g(at);if(!y(xt))return;let Wt=f(xt),Bt=l.BASE.multiply(xt).toAffine(),ft=o(Bt.x);if(ft===Q)return;let vt=o(Wt*o(rt+ft*W));if(vt===Q)return;let bt=(Bt.x===ft?0:2)|Number(Bt.y&U),pe=vt;return O&&I(vt)&&(pe=b(vt),bt^=1),new _(ft,pe,bt)}return{seed:ht,k2sig:Yt}}let v={lowS:n.lowS,prehash:!1},L={lowS:n.lowS,prehash:!1};function S(x,u,p=v){let{seed:q,k2sig:A}=T(x,u,p),O=n;return Ie(O.hash.outputLen,O.nByteLength,O.hmac)(q,A)}l.BASE._setWindowSize(8);function M(x,u,p,q=L){let A=x;u=V("msgHash",u),p=V("publicKey",p);let{lowS:O,prehash:k,format:z}=q;if(ze(q),"strict"in q)throw new Error("options.strict was renamed to lowS");if(z!==void 0&&z!=="compact"&&z!=="der")throw new Error("format must be compact or der");let J=typeof A=="string"||Xt(A),W=!J&&!z&&typeof A=="object"&&A!==null&&typeof A.r=="bigint"&&typeof A.s=="bigint";if(!J&&!W)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let G,ht;try{if(W&&(G=new _(A.r,A.s)),J){try{z!=="compact"&&(G=_.fromDER(A))}catch(bt){if(!(bt instanceof nt.Err))throw bt}!G&&z!=="der"&&(G=_.fromCompact(A))}ht=l.fromHex(p)}catch{return!1}if(!G||O&&G.hasHighS())return!1;k&&(u=n.hash(u));let{r:rt,s:Yt}=G,at=B(u),xt=f(Yt),Wt=o(at*xt),Bt=o(rt*xt),ft=l.BASE.multiplyAndAddUnsafe(ht,Wt,Bt)?.toAffine();return ft?o(ft.x)===rt:!1}return{CURVE:n,getPublicKey:w,getSharedSecret:m,sign:S,verify:M,ProjectivePoint:l,Signature:_,utils:N}}function mn(e,n){let t=e.ORDER,r=Q;for(let I=t-U;I%st===Q;I/=st)r+=U;let i=r,s=st<<i-U-U,c=s*st,a=(t-U)/c,o=(a-U)/st,f=c-U,l=s,h=e.pow(n,a),E=e.pow(n,(a+U)/st),y=(I,b)=>{let C=h,_=e.pow(b,f),N=e.sqr(_);N=e.mul(N,b);let w=e.mul(I,N);w=e.pow(w,o),w=e.mul(w,_),_=e.mul(w,b),N=e.mul(w,I);let d=e.mul(N,_);w=e.pow(d,l);let m=e.eql(w,e.ONE);_=e.mul(N,E),w=e.mul(d,C),N=e.cmov(_,N,m),d=e.cmov(w,d,m);for(let g=i;g>U;g--){let B=g-st;B=st<<B-U;let H=e.pow(d,B),R=e.eql(H,e.ONE);_=e.mul(N,C),C=e.mul(C,C),H=e.mul(d,C),N=e.cmov(_,N,R),d=e.cmov(H,d,R)}return{isValid:m,value:N}};if(e.ORDER%ue===_t){let I=(e.ORDER-_t)/ue,b=e.sqrt(e.neg(n));y=(C,_)=>{let N=e.sqr(_),w=e.mul(C,_);N=e.mul(N,w);let d=e.pow(N,I);d=e.mul(d,w);let m=e.mul(d,b),g=e.mul(e.sqr(d),_),B=e.eql(g,C),H=e.cmov(m,d,B);return{isValid:B,value:H}}}return y}function Ge(e,n){if(zt(e),!e.isValid(n.A)||!e.isValid(n.B)||!e.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");let t=mn(e,n.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let i,s,c,a,o,f,l,h;i=e.sqr(r),i=e.mul(i,n.Z),s=e.sqr(i),s=e.add(s,i),c=e.add(s,e.ONE),c=e.mul(c,n.B),a=e.cmov(n.Z,e.neg(s),!e.eql(s,e.ZERO)),a=e.mul(a,n.A),s=e.sqr(c),f=e.sqr(a),o=e.mul(f,n.A),s=e.add(s,o),s=e.mul(s,c),f=e.mul(f,a),o=e.mul(f,n.B),s=e.add(s,o),l=e.mul(i,c);let{isValid:E,value:y}=t(s,f);h=e.mul(i,r),h=e.mul(h,y),l=e.cmov(l,c,E),h=e.cmov(h,y,E);let I=e.isOdd(r)===e.isOdd(h);h=e.cmov(e.neg(h),h,I);let b=yt(e,[a],!0)[0];return l=e.mul(l,b),{x:l,y:h}}}function wn(e){return{hash:e,hmac:(n,...t)=>ee(e,n,ve(...t)),randomBytes:Ut}}function je(e,n){let t=r=>Pe({...e,...wn(r)});return{...t(n),create:t}}var gn=j;function it(e,n){if(Ht(e),Ht(n),e<0||e>=1<<8*n)throw new Error("invalid I2OSP input: "+e);let t=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)t[r]=e&255,e>>>=8;return new Uint8Array(t)}function pn(e,n){let t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e[r]^n[r];return t}function Ht(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function yn(e,n,t,r){wt(e),wt(n),Ht(t),n.length>255&&(n=r(K(Zt("H2C-OVERSIZE-DST-"),n)));let{outputLen:i,blockLen:s}=r,c=Math.ceil(t/i);if(t>65535||c>255)throw new Error("expand_message_xmd: invalid lenInBytes");let a=K(n,it(n.length,1)),o=it(0,s),f=it(t,2),l=new Array(c),h=r(K(o,e,f,it(0,1),a));l[0]=r(K(h,it(1,1),a));for(let y=1;y<=c;y++){let I=[pn(h,l[y-1]),it(y+1,1),a];l[y]=r(K(...I))}return K(...l).slice(0,t)}function En(e,n,t,r,i){if(wt(e),wt(n),Ht(t),n.length>255){let s=Math.ceil(2*r/8);n=i.create({dkLen:s}).update(Zt("H2C-OVERSIZE-DST-")).update(n).digest()}if(t>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return i.create({dkLen:t}).update(e).update(it(t,2)).update(n).update(it(n.length,1)).digest()}function Ke(e,n,t){tt(t,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});let{p:r,k:i,m:s,hash:c,expand:a,DST:o}=t;wt(e),Ht(n);let f=typeof o=="string"?Zt(o):o,l=r.toString(2).length,h=Math.ceil((l+i)/8),E=n*s*h,y;if(a==="xmd")y=yn(e,f,E,c);else if(a==="xof")y=En(e,f,E,i,c);else if(a==="_internal_pass")y=e;else throw new Error('expand must be "xmd" or "xof"');let I=new Array(n);for(let b=0;b<n;b++){let C=new Array(s);for(let _=0;_<s;_++){let N=h*(_+b*s),w=y.subarray(N,N+h);C[_]=Z(gn(w),r)}I[b]=C}return I}function Ye(e,n){let t=n.map(r=>Array.from(r).reverse());return(r,i)=>{let[s,c,a,o]=t.map(h=>h.reduce((E,y)=>e.add(e.mul(E,r),y))),[f,l]=yt(e,[c,o],!0);return r=e.mul(s,f),i=e.mul(i,e.mul(a,l)),{x:r,y:i}}}function We(e,n,t){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(s){return e.fromAffine(n(s))}function i(s){let c=s.clearCofactor();return c.equals(e.ZERO)?e.ZERO:(c.assertValidity(),c)}return{defaults:t,hashToCurve(s,c){let a=Ke(s,2,{...t,DST:t.DST,...c}),o=r(a[0]),f=r(a[1]);return i(o.add(f))},encodeToCurve(s,c){let a=Ke(s,1,{...t,DST:t.encodeDST,...c});return i(r(a[0]))},mapToCurve(s){if(!Array.isArray(s))throw new Error("expected array of bigints");for(let c of s)if(typeof c!="bigint")throw new Error("expected array of bigints");return i(r(s))}}}var Lt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Pt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),me=BigInt(0),Ot=BigInt(1),Gt=BigInt(2),Xe=(e,n)=>(e+n/Gt)/n;function Je(e){let n=Lt,t=BigInt(3),r=BigInt(6),i=BigInt(11),s=BigInt(22),c=BigInt(23),a=BigInt(44),o=BigInt(88),f=e*e*e%n,l=f*f*e%n,h=Y(l,t,n)*l%n,E=Y(h,t,n)*l%n,y=Y(E,Gt,n)*f%n,I=Y(y,i,n)*y%n,b=Y(I,s,n)*I%n,C=Y(b,a,n)*b%n,_=Y(C,o,n)*C%n,N=Y(_,a,n)*b%n,w=Y(N,t,n)*l%n,d=Y(w,c,n)*I%n,m=Y(d,r,n)*f%n,g=Y(m,Gt,n);if(!ct.eql(ct.sqr(g),e))throw new Error("Cannot find square root");return g}var ct=It(Lt,void 0,void 0,{sqrt:Je}),Kt=je({a:me,b:BigInt(7),Fp:ct,n:Pt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{let n=Pt,t=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Ot*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=t,c=BigInt("0x100000000000000000000000000000000"),a=Xe(s*e,n),o=Xe(-r*e,n),f=Z(e-a*t-o*i,n),l=Z(-a*r-o*s,n),h=f>c,E=l>c;if(h&&(f=n-f),E&&(l=n-l),f>c||l>c)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:h,k1:f,k2neg:E,k2:l}}}},At),Qe={};function jt(e,...n){let t=Qe[e];if(t===void 0){let r=At(Uint8Array.from(e,i=>i.charCodeAt(0)));t=K(r,r),Qe[e]=t}return At(K(t,...n))}var we=e=>e.toRawBytes(!0).slice(1),xe=e=>$(e,32),he=e=>Z(e,Lt),qt=e=>Z(e,Pt),ge=Kt.ProjectivePoint,Bn=(e,n,t)=>ge.BASE.multiplyAndAddUnsafe(e,n,t);function be(e){let n=Kt.utils.normPrivateKeyToScalar(e),t=ge.fromPrivateKey(n);return{scalar:t.hasEvenY()?n:qt(-n),bytes:we(t)}}function $e(e){F("x",e,Ot,Lt);let n=he(e*e),t=he(n*e+BigInt(7)),r=Je(t);r%Gt!==me&&(r=he(-r));let i=new ge(e,r,Ot);return i.assertValidity(),i}var Et=j;function Fe(...e){return qt(Et(jt("BIP0340/challenge",...e)))}function vn(e){return be(e).bytes}function Sn(e,n,t=Ut(32)){let r=V("message",e),{bytes:i,scalar:s}=be(n),c=V("auxRand",t,32),a=xe(s^Et(jt("BIP0340/aux",c))),o=jt("BIP0340/nonce",a,i,r),f=qt(Et(o));if(f===me)throw new Error("sign failed: k is zero");let{bytes:l,scalar:h}=be(f),E=Fe(l,i,r),y=new Uint8Array(64);if(y.set(l,0),y.set(xe(qt(h+E*s)),32),!tn(y,r,i))throw new Error("sign: Invalid signature produced");return y}function tn(e,n,t){let r=V("signature",e,64),i=V("message",n),s=V("publicKey",t,32);try{let c=$e(Et(s)),a=Et(r.subarray(0,32));if(!pt(a,Ot,Lt))return!1;let o=Et(r.subarray(32,64));if(!pt(o,Ot,Pt))return!1;let f=Fe(xe(a),we(c),i),l=Bn(c,o,qt(-f));return!(!l||!l.hasEvenY()||l.toAffine().x!==a)}catch{return!1}}var cr={getPublicKey:vn,sign:Sn,verify:tn,utils:{randomPrivateKey:Kt.utils.randomPrivateKey,lift_x:$e,pointToBytes:we,numberToBytesBE:$,bytesToNumberBE:j,taggedHash:jt,mod:Z}},An=Ye(ct,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(e=>e.map(n=>BigInt(n)))),In=Ge(ct,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:ct.create(BigInt("-11"))}),en=We(Kt.ProjectivePoint,e=>{let{x:n,y:t}=In(ct.create(e[0]));return An(n,t)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:ct.ORDER,m:1,k:128,expand:"xmd",hash:At}),ar=en.hashToCurve,fr=en.encodeToCurve;export{At as a,Kt as b,cr as c,en as d,ar as e,fr as f};
/*! Bundled license information:

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
