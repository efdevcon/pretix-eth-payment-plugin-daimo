var O=new Map,b=d=>{let i=O.get(d);return i?Object.fromEntries(Object.entries(i.stores).map(([n,r])=>[n,r.getState()])):{}},C=(d,i,n)=>{if(d===void 0)return{type:"untracked",connection:i.connect(n)};let r=O.get(n.name);if(r)return{type:"tracked",store:d,...r};let t={connection:i.connect(n),stores:{}};return O.set(n.name,t),{type:"tracked",store:d,...t}},j=(d,i={})=>(n,r,t)=>{let{enabled:u,anonymousActionType:v,store:o,...m}=i,l;try{l=(u??(import.meta.env?import.meta.env.MODE:void 0)!=="production")&&window.__REDUX_DEVTOOLS_EXTENSION__}catch{}if(!l)return d(n,r,t);let{connection:s,...S}=C(o,l,m),y=!0;t.setState=(e,h,a)=>{let c=n(e,h);if(!y)return c;let p=a===void 0?{type:v||"anonymous"}:typeof a=="string"?{type:a}:a;return o===void 0?(s?.send(p,r()),c):(s?.send({...p,type:`${o}/${p.type}`},{...b(m.name),[o]:t.getState()}),c)};let f=(...e)=>{let h=y;y=!1,n(...e),y=h},g=d(t.setState,r,t);if(S.type==="untracked"?s?.init(g):(S.stores[S.store]=t,s?.init(Object.fromEntries(Object.entries(S.stores).map(([e,h])=>[e,e===S.store?g:h.getState()])))),t.dispatchFromDevtools&&typeof t.dispatch=="function"){let e=!1,h=t.dispatch;t.dispatch=(...a)=>{(import.meta.env?import.meta.env.MODE:void 0)!=="production"&&a[0].type==="__setState"&&!e&&(console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.'),e=!0),h(...a)}}return s.subscribe(e=>{var h;switch(e.type){case"ACTION":if(typeof e.payload!="string"){console.error("[zustand devtools middleware] Unsupported action format");return}return I(e.payload,a=>{if(a.type==="__setState"){if(o===void 0){f(a.state);return}Object.keys(a.state).length!==1&&console.error(`
                    [zustand devtools middleware] Unsupported __setState action format.
                    When using 'store' option in devtools(), the 'state' should have only one key, which is a value of 'store' that was passed in devtools(),
                    and value of this only key should be a state object. Example: { "type": "__setState", "state": { "abc123Store": { "foo": "bar" } } }
                    `);let c=a.state[o];if(c==null)return;JSON.stringify(t.getState())!==JSON.stringify(c)&&f(c);return}t.dispatchFromDevtools&&typeof t.dispatch=="function"&&t.dispatch(a)});case"DISPATCH":switch(e.payload.type){case"RESET":return f(g),o===void 0?s?.init(t.getState()):s?.init(b(m.name));case"COMMIT":if(o===void 0){s?.init(t.getState());return}return s?.init(b(m.name));case"ROLLBACK":return I(e.state,a=>{if(o===void 0){f(a),s?.init(t.getState());return}f(a[o]),s?.init(b(m.name))});case"JUMP_TO_STATE":case"JUMP_TO_ACTION":return I(e.state,a=>{if(o===void 0){f(a);return}JSON.stringify(t.getState())!==JSON.stringify(a[o])&&f(a[o])});case"IMPORT_STATE":{let{nextLiftedState:a}=e.payload,c=(h=a.computedStates.slice(-1)[0])==null?void 0:h.state;if(!c)return;f(o===void 0?c:c[o]),s?.send(null,a);return}case"PAUSE_RECORDING":return y=!y}return}}),g},J=j,I=(d,i)=>{let n;try{n=JSON.parse(d)}catch(r){console.error("[zustand devtools middleware] Could not parse the received json",r)}n!==void 0&&i(n)},N=d=>(i,n,r)=>{let t=r.subscribe;return r.subscribe=(v,o,m)=>{let l=v;if(o){let s=m?.equalityFn||Object.is,S=v(r.getState());l=y=>{let f=v(y);if(!s(S,f)){let g=S;o(S=f,g)}},m?.fireImmediately&&o(S,S)}return t(l)},d(i,n,r)},k=N;function R(d,i){let n;try{n=d()}catch{return}return{getItem:t=>{var u;let v=m=>m===null?null:JSON.parse(m,i?.reviver),o=(u=n.getItem(t))!=null?u:null;return o instanceof Promise?o.then(v):v(o)},setItem:(t,u)=>n.setItem(t,JSON.stringify(u,i?.replacer)),removeItem:t=>n.removeItem(t)}}var T=d=>i=>{try{let n=d(i);return n instanceof Promise?n:{then(r){return T(r)(n)},catch(r){return this}}}catch(n){return{then(r){return this},catch(r){return T(r)(n)}}}},D=(d,i)=>(n,r,t)=>{let u={storage:R(()=>localStorage),partialize:e=>e,version:0,merge:(e,h)=>({...h,...e}),...i},v=!1,o=new Set,m=new Set,l=u.storage;if(!l)return d((...e)=>{console.warn(`[zustand persist middleware] Unable to update item '${u.name}', the given storage is currently unavailable.`),n(...e)},r,t);let s=()=>{let e=u.partialize({...r()});return l.setItem(u.name,{state:e,version:u.version})},S=t.setState;t.setState=(e,h)=>{S(e,h),s()};let y=d((...e)=>{n(...e),s()},r,t);t.getInitialState=()=>y;let f,g=()=>{var e,h;if(!l)return;v=!1,o.forEach(c=>{var p;return c((p=r())!=null?p:y)});let a=((h=u.onRehydrateStorage)==null?void 0:h.call(u,(e=r())!=null?e:y))||void 0;return T(l.getItem.bind(l))(u.name).then(c=>{if(c)if(typeof c.version=="number"&&c.version!==u.version){if(u.migrate){let p=u.migrate(c.state,c.version);return p instanceof Promise?p.then(_=>[!0,_]):[!0,p]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,c.state];return[!1,void 0]}).then(c=>{var p;let[_,w]=c;if(f=u.merge(w,(p=r())!=null?p:y),n(f,!0),_)return s()}).then(()=>{a?.(f,void 0),f=r(),v=!0,m.forEach(c=>c(f))}).catch(c=>{a?.(void 0,c)})};return t.persist={setOptions:e=>{u={...u,...e},e.storage&&(l=e.storage)},clearStorage:()=>{l?.removeItem(u.name)},getOptions:()=>u,rehydrate:()=>g(),hasHydrated:()=>v,onHydrate:e=>(o.add(e),()=>{o.delete(e)}),onFinishHydration:e=>(m.add(e),()=>{m.delete(e)})},u.skipHydration||g(),f||y},x=D;var E=d=>{let i,n=new Set,r=(l,s)=>{let S=typeof l=="function"?l(i):l;if(!Object.is(S,i)){let y=i;i=s??(typeof S!="object"||S===null)?S:Object.assign({},i,S),n.forEach(f=>f(i,y))}},t=()=>i,o={setState:r,getState:t,getInitialState:()=>m,subscribe:l=>(n.add(l),()=>n.delete(l))},m=i=d(r,t,o);return o},A=d=>d?E(d):E;export{J as a,k as b,R as c,x as d,A as e};
